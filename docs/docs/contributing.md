---
sidebar_position: 100
---

# Contributing

Guidelines for contributing to FPL.

## Requirements

- **Fortran 90 only** — no F2003+ features (`class`, `type-bound procedures`, `abstract interfaces`, etc.)
- GFortran (any recent version)
- NetCDF-Fortran libraries

## Code Conventions

### Intent Declarations

All subroutine/function arguments **must** have `intent` specified:

```fortran
subroutine example(input, output, both)
  integer, intent(in)    :: input
  integer, intent(out)   :: output
  integer, intent(inout) :: both
```

### Allocation Safety

Always use `stat=` with `allocate` / `deallocate` and check with `check_alloc`:

```fortran
integer :: istat
allocate(array(n), stat=istat)
call check_alloc(istat, "array")
```

### Loop Order

Fortran uses **column-major** storage. Always iterate with the **first index in the innermost loop**:

```fortran
! Correct
do j = 1, nlats
  do i = 1, nlons
    data(i, j) = ...
  end do
end do

! Wrong — causes cache misses
do i = 1, nlons
  do j = 1, nlats
    data(i, j) = ...
  end do
end do
```

### No system() Calls

Use pure Fortran I/O instead of `call system(...)`. See `print_filename` in `FPL_checkerror.f90` for an example.

### Type Naming

Follow the existing convention:

```
nc{D}d_{type}_{coord}[_t{ttype}][_l{ltype}]
```

## Workflow

1. Fork the repository
2. Create a feature branch from `dev`
3. Write your changes following the conventions above
4. Test by compiling the library and running the examples
5. Submit a pull request to `dev`

## Building & Testing

```bash
make          # Build libFPL.so
make examples # Compile example programs
```

## Code Generation

Many source files are generated by shell scripts in `shell_gencodes/`. If you add a new data type variant, update the relevant script and regenerate.
